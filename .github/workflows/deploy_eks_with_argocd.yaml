name: Manage EKS Cluster

on:
  workflow_dispatch:
    inputs:
      clusterName:
        description: 'Cluster Name'
        required: true
      region:
        description: 'Region'
        required: true     
      repoURLforArgo: 
        description: 'The URL of the repository for Argo CD to deploy GKE'
        required: true
jobs:
  deploy-cluster:
    runs-on: ubuntu-latest
    steps:
    - name: Install jq
      run: sudo apt-get install -y jq

    - name: Checkout Code
      uses: actions/checkout@v2

    - name: Install Argo CD CLI
      run: |
        sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        sudo chmod +x /usr/local/bin/argocd

    - name: Login to Argo CD 
      run: argocd login ${{ secrets.ARGOCD_SERVER }} --username ${{ secrets.ARGOCD_USER }} --password ${{ secrets.ARGOCD_PASS }} --insecure --grpc-web 

    - name: Register Repository in Argo CD
      run: argocd repo add ${{ github.event.inputs.repoURLforArgo }} --username hoanglecao --password ${{ secrets.MYGITHUB_TOKEN }}

    - name: Create ArgoCD app for AWS provider
      run: |
          # Check if the ArgoCD app exists
          if argocd app get aws-provider-app > /dev/null 2>&1; then
            echo "aws-provider-app already exists"
          else
            argocd app create aws-provider-app \
              --repo ${{ github.event.inputs.repoURLforArgo }} \
              --path aws \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace aws-provider \
              --project default \
              --sync-policy automated \
              --sync-option CreateNamespace=true \
              --sync-retry-limit 5 \
              --upsert \
              --grpc-web
          fi
    - name: Wait for aws-provider-app to become synced
      run: |
            # Initialize time
            TIMEOUT=660
            INTERVAL=60
            ELAPSED=0

            # Loop until the app becomes healthy and synced or we hit the timeout
            while [[ $ELAPSED -lt $TIMEOUT ]]; do
              # Get the health status and sync status of the application
              APP_STATUS=$(argocd app get aws-provider-app --output json)
              HEALTH_STATUS=$(echo "$APP_STATUS" | jq -r '.status.health.status')
              SYNC_STATUS=$(echo "$APP_STATUS" | jq -r '.status.sync.status')

              echo "Application health status: $HEALTH_STATUS"
              echo "Application sync status: $SYNC_STATUS"

              # If the app is both healthy and synced, break out of the loop
              if [[ "$HEALTH_STATUS" == "Healthy" && "$SYNC_STATUS" == "Synced" ]]; then
                echo "aws-provider-app is healthy and synced. Proceeding..."
                break
              fi

              # Wait for the interval duration before checking again
              echo "Waiting for aws-provider-app to become healthy and synced..."
              sleep $INTERVAL

              # Increment the elapsed time
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            # If the app is still not healthy or synced after the timeout, exit with an error
            if [[ "$HEALTH_STATUS" != "Healthy" || "$SYNC_STATUS" != "Synced" ]]; then
              echo "aws-provider-app did not become healthy and synced within $TIMEOUT seconds. Exiting..."
              exit 1
            fi


    - name: Create ArgoCD app for VPC
      run: |
          # Check if the ArgoCD app exists
          argocd app create vpc-${{ github.event.inputs.clusterName }}-app \
              --repo ${{ github.event.inputs.repoURLforArgo }} \
              --path vpc \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace aws-provider \
              --project default \
              --sync-policy automated \
              --sync-retry-limit 5 \
              --upsert \
              --grpc-web

    - name: Wait for vpc-${{ github.event.inputs.clusterName }}-app to become synced
      run: |
            # Initialize time
            TIMEOUT=660
            INTERVAL=60
            ELAPSED=0

            # Loop until the app becomes healthy and synced or we hit the timeout
            while [[ $ELAPSED -lt $TIMEOUT ]]; do
              # Get the health status and sync status of the application
              APP_STATUS=$(argocd app get vpc-${{ github.event.inputs.clusterName }}-app --output json)
              HEALTH_STATUS=$(echo "$APP_STATUS" | jq -r '.status.health.status')
              SYNC_STATUS=$(echo "$APP_STATUS" | jq -r '.status.sync.status')

              echo "Application health status: $HEALTH_STATUS"
              echo "Application sync status: $SYNC_STATUS"

              # If the app is both healthy and synced, break out of the loop
              if [[ "$HEALTH_STATUS" == "Healthy" && "$SYNC_STATUS" == "Synced" ]]; then
                echo "vpc-${{ github.event.inputs.clusterName }}-app is healthy and synced. Proceeding..."
                break
              fi

              # Wait for the interval duration before checking again
              echo "Waiting for vpc-${{ github.event.inputs.clusterName }}-app to become healthy and synced..."
              sleep $INTERVAL

              # Increment the elapsed time
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            # If the app is still not healthy or synced after the timeout, exit with an error
            if [[ "$HEALTH_STATUS" != "Healthy" || "$SYNC_STATUS" != "Synced" ]]; then
              echo "vpc-${{ github.event.inputs.clusterName }}-app did not become healthy and synced within $TIMEOUT seconds. Exiting..."
              exit 1
            fi
    - name: Create ArgoCD app for EKD cluster
      run: |
          # Check if the ArgoCD app exists
          argocd app create eks-${{ github.event.inputs.clusterName }}-app \
              --repo ${{ github.event.inputs.repoURLforArgo }} \
              --path eks-cluster \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace aws-provider \
              --project default \
              --sync-policy automated \
              --sync-retry-limit 5 \
              --upsert \
              --grpc-web
              
    - name: Wait for eks-${{ github.event.inputs.clusterName }}-app to become synced
      run: |
            # Initialize time
            TIMEOUT=660
            INTERVAL=60
            ELAPSED=0

            # Loop until the app becomes healthy and synced or we hit the timeout
            while [[ $ELAPSED -lt $TIMEOUT ]]; do
              # Get the health status and sync status of the application
              APP_STATUS=$(argocd app get eks-${{ github.event.inputs.clusterName }}-app --output json)
              HEALTH_STATUS=$(echo "$APP_STATUS" | jq -r '.status.health.status')
              SYNC_STATUS=$(echo "$APP_STATUS" | jq -r '.status.sync.status')

              echo "Application health status: $HEALTH_STATUS"
              echo "Application sync status: $SYNC_STATUS"

              # If the app is both healthy and synced, break out of the loop
              if [[ "$HEALTH_STATUS" == "Healthy" && "$SYNC_STATUS" == "Synced" ]]; then
                echo "eks-${{ github.event.inputs.clusterName }}-app is healthy and synced. Proceeding..."
                break
              fi

              # Wait for the interval duration before checking again
              echo "Waiting for eks-${{ github.event.inputs.clusterName }}-app to become healthy and synced..."
              sleep $INTERVAL

              # Increment the elapsed time
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            # If the app is still not healthy or synced after the timeout, exit with an error
            if [[ "$HEALTH_STATUS" != "Healthy" || "$SYNC_STATUS" != "Synced" ]]; then
              echo "eks-${{ github.event.inputs.clusterName }}-app did not become healthy and synced within $TIMEOUT seconds. Exiting..."
              exit 1
            fi